<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labs Experiment Hub</title>

    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#8ab4f8">
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js')
            .then(reg => console.log('Service Worker Registered'))
            .catch(err => console.log('Service Worker Failed', err));
        });
      }
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Typography */
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;700&family=Space+Mono:wght@400;700&display=swap');
        
        :root {
            --bg-color: #202124;
            --surface-color: #303134;
            --primary-accent: #8ab4f8; 
            --orb-color: #8ab4f8; 
        }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg-color);
            color: #e8eaed;
            background-image: radial-gradient(#3c4043 1px, transparent 1px);
            background-size: 24px 24px;
        }

        .font-mono { font-family: 'Space Mono', monospace; }

        /* Sliders */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
            height: 32px; 
            display: flex;
            align-items: center;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px; 
            border-radius: 50%;
            background: #e8eaed;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 0 2px #303134; 
            transition: all 0.2s ease;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            cursor: pointer;
            background: #5f6368;
            border-radius: 999px;
        }
        input[type=range]:focus { outline: none; }

        /* Common Transitions */
        .pill-btn, .tab-btn, .icon-btn {
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .pill-btn:active, .icon-btn:active { transform: scale(0.96); }

        /* Noise Circle Button */
        .noise-circle {
            /* Transition width/height/shadow/border, but NOT transform (handled by random offset) */
            transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1), 
                        height 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
                        box-shadow 0.3s ease,
                        background-color 0.3s ease;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 2px solid transparent; /* slightly thicker border for color pop */
        }
        
        /* Inactive State */
        .noise-circle.inactive {
            width: 56px;
            height: 56px;
            font-size: 10px;
            font-family: 'Space Mono', monospace;
            text-transform: uppercase;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            opacity: 0.8;
        }
        .noise-circle.inactive:hover {
            transform: scale(1.1); /* This might conflict with inline transform, handled in JS or specific logic below */
            opacity: 1;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 5;
        }

        /* Active State (The "Planet") */
        .noise-circle.active {
            width: 180px;
            height: 180px;
            background-color: #000 !important; /* Force black center for vis */
            box-shadow: 0 0 40px rgba(0,0,0,0.4);
            z-index: 10;
            opacity: 1;
        }

        /* Canvas inside circle */
        .circle-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .noise-circle.active .circle-canvas {
            opacity: 1;
        }

        /* Overlay Icon on Active Circle */
        .play-overlay {
            opacity: 0;
            transition: opacity 0.2s;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(2px);
        }
        .noise-circle.active:hover .play-overlay {
            opacity: 1;
        }
        /* Always show if paused and active */
        .noise-circle.active.is-paused .play-overlay {
            opacity: 1;
            background: rgba(0,0,0,0.6);
        }

        /* Active States for tabs/toggles */
        .pill-btn.active, .icon-btn.active {
            background-color: #e8eaed;
            color: #202124;
            font-weight: 600;
        }
        
        .tab-btn.active {
            color: #e8eaed;
            border-bottom: 2px solid #8ab4f8;
        }
        .tab-btn {
            color: #9aa0a6;
            border-bottom: 2px solid transparent;
        }

        /* Breathing Orb */
        .breathing-orb {
            transition-property: transform, background-color, box-shadow;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 60px var(--orb-color);
            background-color: var(--orb-color);
            cursor: pointer;
        }
        .breathing-orb:hover { transform: scale(1.05); }
        .breathing-orb:active { transform: scale(0.95); }
        
        .hidden-tab { display: none !important; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 selection:bg-blue-300 selection:text-black">

    <div class="max-w-xl w-full bg-[#303134] rounded-[2.5rem] p-6 md:p-8 shadow-2xl relative overflow-hidden">
        
        <!-- Header & Tabs -->
        <div class="flex items-start justify-between mb-4">
            <div>
                <div class="flex items-center gap-2 mb-1">
                    <span class="bg-[#8ab4f8] text-[#202124] text-[10px] font-bold font-mono px-2 py-0.5 rounded-full uppercase tracking-wider">Hub 01</span>
                </div>
                <h1 class="text-3xl font-normal tracking-tight text-[#e8eaed]">Focus Labs</h1>
            </div>
            <!-- Google-esque Branding -->
            <div class="flex gap-1 mt-2">
                <div class="w-2 h-2 rounded-full bg-[#8ab4f8]"></div>
                <div class="w-2 h-2 rounded-full bg-[#f28b82]"></div>
                <div class="w-2 h-2 rounded-full bg-[#fdd663]"></div>
                <div class="w-2 h-2 rounded-full bg-[#81c995]"></div>
            </div>
        </div>

        <!-- Navigation Tabs -->
        <div class="flex gap-6 mb-6 border-b border-[#5f6368]">
            <button onclick="switchTab('noise')" id="tab-noise-btn" class="tab-btn active pb-2 text-sm font-medium tracking-wide">Noise Gen</button>
            <button onclick="switchTab('breathe')" id="tab-breathe-btn" class="tab-btn pb-2 text-sm font-medium tracking-wide">Breathing</button>
        </div>

        <!-- TAB 1: NOISE GENERATOR -->
        <div id="tab-noise-content" class="flex flex-col h-[480px] relative">
            
            <!-- 1. Circular Source Grid (Organic Constellation) -->
            <!-- Using content-center to keep them visually centered despite offsets -->
            <div id="noise-grid" class="flex-1 flex flex-wrap content-center items-center justify-center gap-12 py-4 px-4 overflow-hidden">
                
                <!-- Canvas is initially here, JS moves it -->
                <canvas id="visualizer" class="circle-canvas"></canvas>

                <!-- Generated via JS -->
            </div>

            <!-- Controls Area (Tone, Timer, Vol) -->
            <div class="w-full pt-4 border-t border-[#3c4043] space-y-4 z-20 bg-[#303134]">
                
                <!-- Top Row: Tone & Timer & Vis Mode -->
                <div class="flex justify-between items-center gap-2">
                    <!-- Tone Slider (Compact) -->
                    <div class="flex-1 flex items-center gap-2 bg-[#202124] rounded-full px-3 py-1.5 border border-[#3c4043]">
                        <span class="font-mono text-[9px] uppercase text-[#9aa0a6]">Tone</span>
                        <input type="range" id="tone" min="200" max="20000" step="100" value="20000" class="w-full h-1">
                    </div>

                    <!-- Spatial Toggle -->
                    <button id="btn-spatial" onclick="toggleSpatial()" class="icon-btn w-8 h-8 rounded-full bg-[#3c4043] flex items-center justify-center text-[#e8eaed] hover:bg-[#4b4d51]" title="Spatial Drift">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6.364 6.364 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                    </button>

                    <!-- Timer Toggle -->
                    <button id="btn-timer" onclick="cycleNoiseTimer()" class="icon-btn px-3 py-1.5 rounded-full bg-[#3c4043] text-[10px] font-mono font-bold text-[#e8eaed] hover:bg-[#4b4d51]">
                        T: Off
                    </button>
                    
                    <!-- Vis Mode Toggle -->
                    <button id="btn-vis-mode" onclick="toggleVisMode()" class="icon-btn w-8 h-8 rounded-full bg-[#3c4043] flex items-center justify-center text-[#e8eaed] hover:bg-[#4b4d51]" title="Switch Visualizer">
                        <svg id="icon-wave" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12h5l3 5 4-10 3 5h5"/></svg>
                    </button>
                </div>

                <!-- Volume Row -->
                <div class="flex items-center gap-3">
                    <span class="font-mono text-[10px] uppercase text-[#9aa0a6] w-8">Vol</span>
                    <input type="range" id="volume" min="0" max="1" step="0.01" value="0.2" class="w-full">
                    <span id="volume-label" class="font-mono text-xs text-[#e8eaed] w-8 text-right">20%</span>
                </div>
            </div>
        </div>

        <!-- TAB 2: BREATHING APP -->
        <div id="tab-breathe-content" class="hidden-tab h-[480px] flex flex-col items-center justify-between py-4">
            
            <div class="w-full flex justify-center gap-2 mb-2">
                <button onclick="selectBreathPattern('box')" id="breath-box" class="pill-btn active px-4 py-2 rounded-full text-xs font-mono uppercase bg-[#e8eaed] text-[#202124] hover:bg-white">Box (4-4-4-4)</button>
                <button onclick="selectBreathPattern('relax')" id="breath-relax" class="pill-btn px-4 py-2 rounded-full text-xs font-mono uppercase bg-[#3c4043] text-[#e8eaed] hover:bg-[#4b4d51]">Relax (4-7-8)</button>
            </div>

            <div class="relative flex-1 flex flex-col items-center justify-center w-full">
                <div id="breath-orb" onclick="toggleBreathing()" class="breathing-orb rounded-full flex items-center justify-center" style="width: 180px; height: 180px; transform: scale(1);">
                    <div class="text-center z-10 pointer-events-none mix-blend-difference text-white">
                        <div id="breath-phase-text" class="text-2xl font-bold tracking-tight">Start</div>
                        <div id="breath-timer-text" class="font-mono text-xs opacity-70 mt-1 uppercase tracking-wide">Tap to begin</div>
                    </div>
                </div>
                
                <div class="absolute inset-0 flex items-center justify-center pointer-events-none opacity-20">
                     <div class="w-[280px] h-[280px] border border-dashed border-[#e8eaed] rounded-full animate-[spin_60s_linear_infinite]"></div>
                     <div class="w-[400px] h-[400px] border border-[#5f6368] rounded-full absolute opacity-30"></div>
                </div>
            </div>
            
            <div class="w-full flex justify-center gap-4 border-t border-[#3c4043] pt-4">
                <button id="btn-breath-tone" onclick="toggleBreathTone()" class="icon-btn px-4 py-2 rounded-full bg-[#3c4043] text-xs font-mono uppercase text-[#e8eaed] hover:bg-[#4b4d51] flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H2v6h4l5 4V5z"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>
                    Chime: <span id="breath-tone-label">Off</span>
                </button>

                <button id="btn-breath-timer" onclick="cycleBreathTimer()" class="icon-btn px-4 py-2 rounded-full bg-[#3c4043] text-xs font-mono uppercase text-[#e8eaed] hover:bg-[#4b4d51] flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                    Timer: <span id="breath-timer-label">Off</span>
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- TABS LOGIC ---
        function switchTab(tab) {
            const noiseContent = document.getElementById('tab-noise-content');
            const breatheContent = document.getElementById('tab-breathe-content');
            const noiseBtn = document.getElementById('tab-noise-btn');
            const breatheBtn = document.getElementById('tab-breathe-btn');

            if (tab === 'noise') {
                noiseContent.classList.remove('hidden-tab');
                breatheContent.classList.add('hidden-tab');
                noiseBtn.classList.add('active');
                breatheBtn.classList.remove('active');
                setTimeout(resizeCanvas, 50); 
            } else {
                noiseContent.classList.add('hidden-tab');
                breatheContent.classList.remove('hidden-tab');
                noiseBtn.classList.remove('active');
                breatheBtn.classList.add('active');
            }
        }

        // ==========================================
        //  SHARED AUDIO CONTEXT
        // ==========================================
        let audioCtx;
        function getAudioCtx() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            return audioCtx;
        }

        // ==========================================
        //  PART 1: NOISE GENERATOR ENGINE
        // ==========================================
        const noiseConfig = {
            white: { color: '#e8eaed', bg: '#e8eaed', text: '#202124' },
            pink: { color: '#f28b82', bg: '#f28b82', text: '#202124' },
            brown: { color: '#fdd663', bg: '#fdd663', text: '#202124' },
            gray: { color: '#bdc1c6', bg: '#bdc1c6', text: '#202124' },
            blue: { color: '#8ab4f8', bg: '#8ab4f8', text: '#202124' },
            violet: { color: '#c58af9', bg: '#c58af9', text: '#202124' },
            green: { color: '#81c995', bg: '#81c995', text: '#202124' }
        };
        const colorKeys = Object.keys(noiseConfig);
        const FADE_DURATION = 0.5;

        // Audio State
        let masterGain, toneFilter, pannerNode, analyser;
        let activeSource = null, activeSourceGain = null;
        let isPlaying = false, currentNoiseType = 'white', bufferCache = {};
        let visualizerMode = 'wave', isSpatialActive = false, spatialStartTime = 0;
        let noiseTimerDuration = 0, noiseTimerTimeout = null;
        let visualizerFrameId, isVisualizerActive = false;

        // Elements
        const volumeSlider = document.getElementById('volume');
        const volumeLabel = document.getElementById('volume-label');
        const toneSlider = document.getElementById('tone');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        const spatialBtn = document.getElementById('btn-spatial');
        const noiseTimerBtn = document.getElementById('btn-timer');
        const gridContainer = document.getElementById('noise-grid');

        // --- DYNAMIC BUTTON GENERATION ---
        function initNoiseButtons() {
            colorKeys.forEach((type, index) => {
                const btn = document.createElement('div');
                btn.id = `btn-${type}`;
                const config = noiseConfig[type];
                
                // Base classes
                btn.className = `noise-circle inactive rounded-full`;
                
                // Random organic offset
                // Using a deterministic random based on index to keep layout somewhat consistent between reloads if desired,
                // or purely random. Let's do purely random but constrained.
                const randomX = (Math.random() - 0.5) * 35; // +/- 17.5px
                const randomY = (Math.random() - 0.5) * 35; 
                btn.style.transform = `translate(${randomX}px, ${randomY}px)`;
                
                // Apply source color immediately
                btn.style.backgroundColor = config.bg;
                btn.style.color = config.text;
                btn.style.borderColor = 'transparent';

                // Add click handler
                btn.onclick = (e) => handleCircleClick(type);
                
                const label = document.createElement('span');
                label.textContent = type;
                label.className = "pointer-events-none";
                
                // Play/Pause Overlay
                const overlay = document.createElement('div');
                overlay.className = "play-overlay absolute inset-0 flex items-center justify-center rounded-full pointer-events-none";
                overlay.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="currentColor" class="text-white drop-shadow-md"><path d="M8 5v14l11-7z"/></svg>`;
                
                btn.appendChild(label);
                btn.appendChild(overlay);
                gridContainer.appendChild(btn);
            });
            updateCircleState();
        }

        function handleCircleClick(type) {
            if (currentNoiseType === type) {
                // Clicked active circle -> Toggle Play/Pause
                if(isPlaying) stopNoise(); else playNoise();
            } else {
                // Clicked inactive circle -> Switch & Play
                selectNoise(type);
            }
        }

        function updateCircleState() {
            colorKeys.forEach(type => {
                const btn = document.getElementById(`btn-${type}`);
                const overlay = btn.querySelector('.play-overlay');
                const label = btn.querySelector('span');
                const config = noiseConfig[type];

                if (type === currentNoiseType) {
                    // Active State
                    btn.classList.remove('inactive');
                    btn.classList.add('active');
                    btn.style.borderColor = config.color;
                    btn.style.backgroundColor = '#000'; // Canvas bg override
                    
                    // Move canvas here
                    if(!btn.contains(canvas)) {
                        btn.insertBefore(canvas, btn.firstChild);
                        
                        // Animate resize to follow transition
                        let start = null;
                        function step(timestamp) {
                            if (!start) start = timestamp;
                            const progress = timestamp - start;
                            resizeCanvas();
                            if (progress < 600) { 
                                window.requestAnimationFrame(step);
                            }
                        }
                        window.requestAnimationFrame(step);
                    }

                    if(isPlaying) {
                        overlay.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="currentColor" class="text-white drop-shadow-md"><path d="M6 6h12v12H6z"/></svg>`; // Pause
                        btn.classList.remove('is-paused');
                    } else {
                        overlay.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="currentColor" class="text-white drop-shadow-md"><path d="M8 5v14l11-7z"/></svg>`; // Play
                        btn.classList.add('is-paused');
                    }
                    
                    label.style.opacity = '0';
                } else {
                    // Inactive State
                    btn.classList.remove('active');
                    btn.classList.add('inactive');
                    btn.style.borderColor = 'transparent';
                    // Restore original color
                    btn.style.backgroundColor = config.bg;
                    btn.style.color = config.text;
                    
                    label.style.opacity = '1';
                }
            });
        }

        function resizeCanvas() {
            const parent = canvas.parentElement;
            if(parent) {
                const width = Math.floor(parent.offsetWidth);
                const height = Math.floor(parent.offsetHeight);
                if (canvas.width !== width * window.devicePixelRatio || canvas.height !== height * window.devicePixelRatio) {
                    canvas.width = width * window.devicePixelRatio;
                    canvas.height = height * window.devicePixelRatio;
                    canvasCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
                }
            }
        }
        window.addEventListener('resize', resizeCanvas);

        function initNoiseAudio() {
            const ctx = getAudioCtx();
            if (!masterGain) {
                masterGain = ctx.createGain();
                toneFilter = ctx.createBiquadFilter();
                pannerNode = ctx.createStereoPanner();
                analyser = ctx.createAnalyser();
                masterGain.gain.value = volumeSlider.value;
                toneFilter.type = 'lowpass';
                toneFilter.frequency.value = toneSlider.value;
                toneFilter.Q.value = 0.5;
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.7;
                toneFilter.connect(pannerNode);
                pannerNode.connect(masterGain);
                masterGain.connect(analyser);
                analyser.connect(ctx.destination);
            }
        }

        function createNoiseBuffer(type) {
            const ctx = getAudioCtx();
            if (bufferCache[type]) return bufferCache[type];
            const bufferSize = ctx.sampleRate * 5; 
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            const getWhite = () => Math.random() * 2 - 1;

            if (type === 'white') for (let i = 0; i < bufferSize; i++) data[i] = getWhite();
            else if (type === 'pink') {
                let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
                for (let i=0; i<bufferSize; i++) {
                    let white = getWhite();
                    b0 = 0.99886*b0 + white*0.0555179; b1 = 0.99332*b1 + white*0.0750759;
                    b2 = 0.96900*b2 + white*0.1538520; b3 = 0.86650*b3 + white*0.3104856;
                    b4 = 0.55000*b4 + white*0.5329522; b5 = -0.7616*b5 - white*0.0168980;
                    data[i] = b0+b1+b2+b3+b4+b5+b6 + white*0.5362; data[i] *= 0.11; b6 = white*0.115926;
                }
            } else if (type === 'brown') {
                let lastOut = 0;
                for (let i=0; i<bufferSize; i++) {
                    let white = getWhite(); data[i] = (lastOut + (0.02 * white)) / 1.02; lastOut = data[i]; data[i] *= 3.5; 
                }
            } else if (type === 'blue') {
                let lastOut = 0;
                for (let i=0; i<bufferSize; i++) {
                    let white = getWhite(); data[i] = (white - lastOut) * 0.5; lastOut = white; data[i] *= 1.5;
                }
            } else if (type === 'violet') {
                let lastOut=0, lastOut2=0;
                for (let i=0; i<bufferSize; i++) {
                    let white = getWhite(); data[i] = (white - 2*lastOut + lastOut2) * 0.5; lastOut2 = lastOut; lastOut = white; data[i] *= 2.0;
                }
            } else if (type === 'gray') {
                let lob=0, lov=0, lov2=0;
                for (let i=0; i<bufferSize; i++) {
                    let white = getWhite();
                    let brown = (lob + (0.02 * white)) / 1.02; lob = brown;
                    let violet = (white - 2*lov + lov2) * 0.5; lov2 = lov; lov = white;
                    data[i] = (brown*3.0) + (violet*0.8); data[i] *= 0.35;
                }
            } else if (type === 'green') {
                let lastOut = 0;
                for (let i=0; i<bufferSize; i++) {
                    let white = getWhite(); data[i] = (lastOut * 0.9) + (white * 0.2); lastOut = data[i]; data[i] *= 1.5;
                }
            }
            bufferCache[type] = buffer;
            return buffer;
        }

        function playNoise() {
            initNoiseAudio();
            const ctx = getAudioCtx();
            if (activeSource) {
                const oldSource = activeSource;
                const oldEnvelope = activeSourceGain;
                oldEnvelope.gain.cancelScheduledValues(ctx.currentTime);
                oldEnvelope.gain.setValueAtTime(oldEnvelope.gain.value, ctx.currentTime);
                oldEnvelope.gain.linearRampToValueAtTime(0, ctx.currentTime + FADE_DURATION);
                oldSource.stop(ctx.currentTime + FADE_DURATION);
            }
            const buffer = createNoiseBuffer(currentNoiseType);
            const source = ctx.createBufferSource();
            source.buffer = buffer;
            source.loop = true;
            const envelope = ctx.createGain();
            envelope.gain.value = 0; 
            source.connect(envelope);
            envelope.connect(toneFilter);
            source.start();
            envelope.gain.linearRampToValueAtTime(1, ctx.currentTime + FADE_DURATION);
            activeSource = source;
            activeSourceGain = envelope;
            isPlaying = true;
            spatialStartTime = Date.now();
            updateUIState();
            startVisualizer();
            startNoiseTimer();
        }

        function stopNoise() {
            const ctx = getAudioCtx();
            if (activeSource) {
                const oldSource = activeSource;
                const oldEnvelope = activeSourceGain;
                oldEnvelope.gain.cancelScheduledValues(ctx.currentTime);
                oldEnvelope.gain.setValueAtTime(oldEnvelope.gain.value, ctx.currentTime);
                oldEnvelope.gain.linearRampToValueAtTime(0, ctx.currentTime + FADE_DURATION);
                oldSource.stop(ctx.currentTime + FADE_DURATION);
                activeSource = null;
                activeSourceGain = null;
            }
            isPlaying = false;
            updateUIState();
            setTimeout(() => { if (!isPlaying) stopVisualizer(); }, FADE_DURATION * 1000 + 100); 
            if (noiseTimerTimeout) clearTimeout(noiseTimerTimeout);
        }

        function toggleSpatial() {
            isSpatialActive = !isSpatialActive;
            if(!isSpatialActive && pannerNode) pannerNode.pan.setTargetAtTime(0, getAudioCtx().currentTime, 0.5);
            updateSpatialUI();
        }

        function updateSpatialUI() {
            if (isSpatialActive) {
                spatialBtn.classList.add('active');
                spatialBtn.classList.remove('bg-[#3c4043]');
                spatialBtn.style.color = '#202124';
            } else {
                spatialBtn.classList.remove('active');
                spatialBtn.classList.add('bg-[#3c4043]');
                spatialBtn.style.color = '#e8eaed';
            }
        }

        function cycleNoiseTimer() {
            const options = [0, 1, 5, 10, 30, 60];
            const currentIndex = options.indexOf(noiseTimerDuration);
            noiseTimerDuration = options[(currentIndex + 1) % options.length];
            if (noiseTimerDuration === 0) {
                noiseTimerBtn.textContent = "T: Off";
                noiseTimerBtn.classList.remove('active', 'bg-[#8ab4f8]', 'text-[#202124]');
                noiseTimerBtn.classList.add('bg-[#3c4043]', 'text-[#e8eaed]');
            } else {
                noiseTimerBtn.textContent = `T: ${noiseTimerDuration}m`;
                noiseTimerBtn.classList.remove('bg-[#3c4043]', 'text-[#e8eaed]');
                noiseTimerBtn.classList.add('active', 'bg-[#8ab4f8]', 'text-[#202124]');
            }
            if (noiseTimerTimeout) clearTimeout(noiseTimerTimeout);
            if (isPlaying && noiseTimerDuration > 0) startNoiseTimer();
        }

        function startNoiseTimer() {
            if (noiseTimerTimeout) clearTimeout(noiseTimerTimeout);
            if (noiseTimerDuration > 0) {
                noiseTimerTimeout = setTimeout(() => {
                    stopNoise();
                    noiseTimerDuration = 0; cycleNoiseTimer(); noiseTimerDuration = 60; cycleNoiseTimer();
                }, noiseTimerDuration * 60 * 1000);
            }
        }

        function toggleVisMode() {
            visualizerMode = visualizerMode === 'wave' ? 'bar' : 'wave';
        }

        function startVisualizer() {
            if (!isVisualizerActive) { isVisualizerActive = true; drawVisualizer(); }
        }
        function stopVisualizer() {
            isVisualizerActive = false; cancelAnimationFrame(visualizerFrameId);
        }

        function drawVisualizer() {
            if (!isVisualizerActive) return;
            visualizerFrameId = requestAnimationFrame(drawVisualizer);
            if (isSpatialActive && pannerNode && isPlaying) {
                const elapsed = (Date.now() - spatialStartTime) / 1000;
                const x = Math.sin(elapsed * 0.2) * 0.8; 
                pannerNode.pan.setValueAtTime(x, getAudioCtx().currentTime);
            }
            const w = canvas.parentElement ? canvas.parentElement.offsetWidth : 180;
            const h = canvas.parentElement ? canvas.parentElement.offsetHeight : 180;
            const config = noiseConfig[currentNoiseType];
            
            canvasCtx.clearRect(0,0,w,h);
            
            canvasCtx.lineWidth = 2; 
            canvasCtx.strokeStyle = config.color; 
            canvasCtx.fillStyle = config.color;
            const bufferLength = analyser.frequencyBinCount;
            
            if (visualizerMode === 'wave') {
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(dataArray);
                canvasCtx.beginPath();
                const sliceWidth = w * 1.0 / bufferLength;
                let x = 0;
                for(let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0; const y = v * h/2;
                    if(i === 0) canvasCtx.moveTo(x, y); else canvasCtx.lineTo(x, y);
                    x += sliceWidth;
                }
                canvasCtx.lineTo(w, h/2); canvasCtx.stroke();
            } else {
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);
                const bars = 40; 
                const barWidth = (w / bars) * 0.6;
                const step = Math.floor(bufferLength / bars);
                
                for(let i = 0; i < bars; i++) {
                    const val = dataArray[i * step]; const percent = val / 255; const barHeight = percent * h * 0.6;
                    const x = i * (w / bars) + (w/bars - barWidth)/2; 
                    const y = (h - barHeight) / 2; 
                    canvasCtx.globalAlpha = 0.8; 
                    canvasCtx.fillRect(x, y, barWidth, barHeight);
                }
                canvasCtx.globalAlpha = 1.0;
            }
        }

        function selectNoise(type) {
            currentNoiseType = type;
            const config = noiseConfig[type];
            updateCircleState();
            if (isPlaying) playNoise();
        }

        function updateUIState() {
            updateCircleState();
        }

        volumeSlider.addEventListener('input', (e) => {
            const val = e.target.value; volumeLabel.textContent = Math.round(val * 100) + '%';
            if (masterGain) { masterGain.gain.cancelScheduledValues(getAudioCtx().currentTime); masterGain.gain.setValueAtTime(val, getAudioCtx().currentTime); }
        });
        toneSlider.addEventListener('input', (e) => {
            if (toneFilter) toneFilter.frequency.setTargetAtTime(e.target.value, getAudioCtx().currentTime, 0.1);
        });

        // ==========================================
        //  PART 2: BREATHING ENGINE
        // ==========================================
        
        const breathPatterns = {
            box: {
                name: "Box Breathing",
                phases: [
                    { name: "Inhale", duration: 4, scale: 1.4 },
                    { name: "Hold", duration: 4, scale: 1.4 },
                    { name: "Exhale", duration: 4, scale: 1.0 },
                    { name: "Hold", duration: 4, scale: 1.0 }
                ],
                color: '#8ab4f8'
            },
            relax: {
                name: "4-7-8 Relax",
                phases: [
                    { name: "Inhale", duration: 4, scale: 1.4 },
                    { name: "Hold", duration: 7, scale: 1.4 },
                    { name: "Exhale", duration: 8, scale: 1.0 }
                ],
                color: '#81c995'
            }
        };

        let currentBreathPatternKey = 'box';
        let isBreathing = false;
        let isBreathToneOn = false;
        let breathPhaseIndex = 0;
        let breathInterval = null;
        let breathTimeLeft = 4;
        let breathTimerDuration = 0; // 0, 1, 5, 10
        let breathTimerTimeout = null;

        // Elements
        const breathOrb = document.getElementById('breath-orb');
        const breathPhaseText = document.getElementById('breath-phase-text');
        const breathTimerText = document.getElementById('breath-timer-text');
        const btnBox = document.getElementById('breath-box');
        const btnRelax = document.getElementById('breath-relax');
        const btnBreathTone = document.getElementById('btn-breath-tone');
        const breathToneLabel = document.getElementById('breath-tone-label');
        const btnBreathTimer = document.getElementById('btn-breath-timer');
        const breathTimerLabel = document.getElementById('breath-timer-label');

        function selectBreathPattern(key) {
            currentBreathPatternKey = key;
            stopBreathing();
            
            if(key === 'box') {
                btnBox.classList.add('active', 'bg-[#e8eaed]', 'text-[#202124]');
                btnBox.classList.remove('bg-[#3c4043]', 'text-[#e8eaed]');
                btnRelax.classList.remove('active', 'bg-[#e8eaed]', 'text-[#202124]');
                btnRelax.classList.add('bg-[#3c4043]', 'text-[#e8eaed]');
            } else {
                btnRelax.classList.add('active', 'bg-[#e8eaed]', 'text-[#202124]');
                btnRelax.classList.remove('bg-[#3c4043]', 'text-[#e8eaed]');
                btnBox.classList.remove('active', 'bg-[#e8eaed]', 'text-[#202124]');
                btnBox.classList.add('bg-[#3c4043]', 'text-[#e8eaed]');
            }
            document.documentElement.style.setProperty('--orb-color', breathPatterns[key].color);
        }

        function toggleBreathTone() {
            isBreathToneOn = !isBreathToneOn;
            if (isBreathToneOn) {
                breathToneLabel.textContent = "On";
                btnBreathTone.classList.add('active');
                btnBreathTone.classList.remove('bg-[#3c4043]', 'text-[#e8eaed]');
            } else {
                breathToneLabel.textContent = "Off";
                btnBreathTone.classList.remove('active');
                btnBreathTone.classList.add('bg-[#3c4043]', 'text-[#e8eaed]');
            }
        }

        function cycleBreathTimer() {
            const options = [0, 1, 5, 10];
            const idx = options.indexOf(breathTimerDuration);
            breathTimerDuration = options[(idx + 1) % options.length];
            
            if (breathTimerDuration === 0) {
                breathTimerLabel.textContent = "Off";
                btnBreathTimer.classList.remove('active');
                btnBreathTimer.classList.add('bg-[#3c4043]', 'text-[#e8eaed]');
            } else {
                breathTimerLabel.textContent = `${breathTimerDuration}m`;
                btnBreathTimer.classList.add('active');
                btnBreathTimer.classList.remove('bg-[#3c4043]', 'text-[#e8eaed]');
            }
            // Reset if currently active
            if (breathTimerTimeout) clearTimeout(breathTimerTimeout);
            if (isBreathing && breathTimerDuration > 0) startBreathTimer();
        }

        function startBreathTimer() {
            if (breathTimerTimeout) clearTimeout(breathTimerTimeout);
            if (breathTimerDuration > 0) {
                breathTimerTimeout = setTimeout(() => {
                    stopBreathing();
                    breathTimerDuration = 0; cycleBreathTimer(); breathTimerDuration = 10; cycleBreathTimer();
                }, breathTimerDuration * 60 * 1000);
            }
        }

        function playChime() {
            const ctx = getAudioCtx();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            
            osc.connect(gain);
            gain.connect(ctx.destination);
            
            // Soft, bell-like sine wave
            osc.type = 'sine'; 
            osc.frequency.setValueAtTime(523.25, ctx.currentTime); // C5
            
            const t = ctx.currentTime;
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.15, t + 0.05); // Attack
            gain.gain.exponentialRampToValueAtTime(0.001, t + 1.2); // Decay
            
            osc.start(t);
            osc.stop(t + 1.2);
        }

        function toggleBreathing() {
            if(isBreathing) stopBreathing(); else startBreathing();
        }

        function startBreathing() {
            isBreathing = true;
            breathPhaseIndex = 0;
            runBreathPhase();
            startBreathTimer();
        }

        function stopBreathing() {
            isBreathing = false;
            clearTimeout(breathInterval);
            clearInterval(breathCountdown);
            if (breathTimerTimeout) clearTimeout(breathTimerTimeout);

            breathOrb.style.transform = "scale(1)";
            breathPhaseText.textContent = "Start";
            breathTimerText.textContent = "Tap to begin";
            breathTimerText.style.opacity = 1;
        }

        let breathCountdown;

        function runBreathPhase() {
            if (!isBreathing) return;
            const ctx = getAudioCtx();
            const pattern = breathPatterns[currentBreathPatternKey];
            const phase = pattern.phases[breathPhaseIndex];
            
            // 1. Visuals
            breathPhaseText.textContent = phase.name;
            breathTimerText.style.opacity = 1;
            breathOrb.style.transform = `scale(${phase.scale})`;
            breathOrb.style.transitionDuration = `${phase.duration}s`;
            
            breathTimeLeft = phase.duration;
            breathTimerText.textContent = Math.ceil(breathTimeLeft) + 's';

            // 2. Audio (Chime) logic
            if (isBreathToneOn) {
                playChime();
            }

            // 3. Countdown UI
            if(breathCountdown) clearInterval(breathCountdown);
            breathCountdown = setInterval(() => {
                breathTimeLeft -= 0.1;
                if(breathTimeLeft <= 0) breathTimeLeft = 0;
                breathTimerText.textContent = Math.ceil(breathTimeLeft) + 's';
            }, 100);

            // 4. Next Phase
            breathInterval = setTimeout(() => {
                breathPhaseIndex = (breathPhaseIndex + 1) % pattern.phases.length;
                runBreathPhase();
            }, phase.duration * 1000);
        }

        // Init - Initialize Buttons immediately
        initNoiseButtons();
        selectBreathPattern('box');
        switchTab('noise');

    </script>
</body>

</html>
